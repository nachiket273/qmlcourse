---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

(bra-ket)=
# Скобки

Автор(ы):

- [Озерин Алексей](https://github.com/m12sl)
- [Пронькин Алексей](https://github.com/alexey-pronkin)


Дисклеймер: нам нужен инструментарий для работы с более абстрактными пространствами!

Символ Кронекера и остальные специальные тензора -- это удобные примитивы для низкоуровневой работы с матрицами и векторами. Физики смогли придумать поверх примитивов линейной алгебры отличный синтаксический сахар, т.н. нотацию Дирака. Но давайте начнем с определения гильбертова пространства.

## Гильбертово пространство

Гильбертово пространство -- это полное линейное векторное пространство, определяемое:
1) скалярным произведением $(u, v)$, в простейшем частном случае - $(u, v) = u^{\dagger} v$;
2) зафиксированной нормой вида $||v|| = \sqrt{(v,v)}$;
3) метрикой $d(u,v) = ||u-v|| = \sqrt{(u-v,u-v)}$.

## Полное пространство

При нахождении предела некоторой последовательности полное метрическое пространство дает возможность не думать о принадлежности этого предела данному пространству, то есть по своей сути разрешает предельный переход и позволяет доказать множество красивых теорем. Подробнее строгое определение можно посмотреть [тут](https://ru.wikipedia.org/wiki/Полное_метрическое_пространство).

## Нотация Дирака, или Bra-Ket нотация

Напомним, что в гильбертовом пространстве для пространства $H$ определено сопряженное пространство $H^{\dagger}$.
Тогда можно рассмотреть обозначение Ket для элемента $v$ из $H$ как вектор-столбец:

$$
\ket{v} = \begin{bmatrix} v_1 \\ v_2 \\ \vdots \\ v_N \end{bmatrix}
$$

и обозначение Bra для элемента $u$ из сопряженного пространства $H^*$ как сопряженную вектор-строку

$$
\bra{u}= \begin{bmatrix} u_1^* & u_2^* & \cdots & u_N^* \end{bmatrix}
$$

Bra-ket $u$ и $v$ просто задает скалярное произведение между этими элементами:

$$
\bra{u} \ket{v} = u_1^* v_1 + u_2^* v_2 + \cdots + u_N^* v_N =
\begin{bmatrix} u_1^* & u_2^* & \cdots & u_N^* \end{bmatrix}
\begin{bmatrix} v_1 \\ v_2 \\ \vdots \\ v_N \end{bmatrix}
$$

Часто, например, требуется показать два граничных  состояния кубита $\ket{0}$, $\ket{1}$, тогда мы можем записать их просто как вектор-столбцы: $\ket{0} = \begin{bmatrix} 1 \\ 0 \end{bmatrix}$ и $\ket{1} = \begin{bmatrix} 0 \\ 1 \end{bmatrix}$. В следующей лекции этот вопрос будет рассмотрен детальнее.

## Внешнее произведение (outer-product)

Также имеет смысл и переставленная запись Ket-Bra, которая называется [_внешним произведением_](https://en.wikipedia.org/wiki/Outer_product):

$$
\ket{u} \bra{v} = \begin{bmatrix} u_1^* \\ u_2^* \\ \cdots \\ u_N^* \end{bmatrix} \begin{bmatrix} v_1 & v_2 & \vdots & v_N \end{bmatrix} = \begin{bmatrix}
  u_1^* v_1 & u_1^* v_2 & \cdots & u_1^* v_N \\
  u_2^* v_1 & u_2^* v_2 & \cdots & u_2^* v_N \\
  \vdots & \cdots &  \ddots & \vdots\\
  u_N^* v_1 & \cdots & \cdots & u_N^* v_N
\end{bmatrix}
$$

По сути это матрица $N \times N$, то есть новый оператор в гильбертовом пространстве. Не все перестановки имеют смысл, например, нельзя записать $\bra{v} \bra{v}$ или $\ket{u} \ket{v}$.

Мы вернемся к Ket-Bra чуть ниже, когда будем говорить про операторы проекции.

## Эрмитов оператор

Оператор $U$ называется [_эрмитовым_](https://ru.wikipedia.org/wiki/Эрмитов_оператор), если он удовлетворяет равенству $(Uv,u) = (v,Uu)$ для всех $u$, $v$ из $H$ или в матричном виде:

$$
U=U^{\dagger}
$$

## Унитарный оператор

[_Унитарный оператор_](https://en.wikipedia.org/wiki/Unitary_operator) $\hat{U}:H \rightarrow H$ на гильбертовом пространстве $H$ -- это линейный оператор, который удовлетворяет следующему равенству $(Uv, Uu) = (u,v)$ для любых $v \in H$, $u \in H$. Или в матричной форме:

$$
\hat{U}^{\dagger}\hat{U}=\hat{U}\hat{U}^{\dagger}=I
$$

Напомним, что операция $\hat{U}^\dagger$ (другое частое обозначение в работах -- звездочка или $H\hat{U}^{*}=\hat{U}^{H}$) в матричных терминах является последовательным применением операции транспонирования и последующего комплексного сопряжения элементов этой матрицы $\hat{U}^\dagger = \overline{\hat{U}}^T$ (порядок этих операций, естественно, не влияет на результат).

```{code-cell} ipython3
import numpy as np
import scipy as sp
from scipy import linalg

U_hat = np.array([
    [1 + 0j, 0 + 0j],
    [0 + 0j, 1 + 0j]
    ])

U_hat_star_byhands = U_hat.conj().T
U_hat_star_long = np.conjugate(np.transpose(U_hat))

print(np.allclose(U_hat_star_long, U_hat_star_byhands))
```
Также в `Python` для многих операций есть соответствующие методы вместо функций и их сокращения, например `U.transpose()` -- то же самое, что `U.T`, а `U.conjugate()` -- `U.conj()`.

Важное свойство, что любой эрмитов оператор $U$ можно привести к унитарному оператору с помощью взятия матричной экспоненты от матрицы оператора, умноженного на мнимую единицу:

$$
\hat{U} = e^{iU}
$$

Давайте докажем быстро этот факт: для эрмитовых квадратных матриц можно определить матричные функции через спектральное разложение матрицы, которое в силу свойств эрмитовых матриц имеет вид: $U=S \Lambda S^{\dagger}$, где $S$ -- унитарная матрица перехода к тому базису, где изначальный оператор выражается диагональной матрицей. Тогда матричная функция $f(U) = S f(\Lambda) S^{\dagger}$, т.е. мы диагонализируем матрицу и применяем функцию ко всем диагональным элементам, а потом возвращаемся в исходный базис унитарным преобразованием. Соответственно, для экспоненты:

$$
e^V = S e^{\Lambda} S^\dagger.
$$


```{note}
В качестве упражнения для самопроверки можете показать, что такое определение эквивалентно определению через степенной ряд: $e^U = \sum_{k=0}^\infty{1 \over k!}U^k$
```

Доказательство:
Проверим определение унитарной матрицы: $\hat{U}^{\dagger}\hat{U} = (S \exp (i*\Lambda) S^\dagger)^\dagger S \exp (i*\Lambda) S^\dagger$.
Пользуясь тем, что эрмитово сопряжение произведения это произведение эрмитовых сопряжений в обратном порядке ($(AB)^\dagger=B^\dagger A^\dagger$) и что эрмитово сопряжение является обратной операцией к себе ($(A^\dagger)^\dagger = A$), а также тем, что $S$ -- унитарная матрица (то есть $S \cdot S^{\dagger}=I$), получаем:

$$
(S \exp (i*\Lambda) S^\dagger)^\dagger S \exp (i*\Lambda) S^\dagger = S \exp(-i*\Lambda) S^\dagger S \exp (i*\Lambda) S^\dagger = S \exp(-i*\Lambda) \exp (i*\Lambda) S^\dagger
$$

Заметим, что теперь у нас уже скалярная экспонента, которая применяется к элементам диагональной матрицы, и мы можем воспользоваться тем, что произведение экспонент превращается в экспоненту от суммы степеней:

$$
S \exp(-i \Lambda  + i \Lambda) S^\dagger = S \exp(O) S^\dagger = S I S^\dagger = I
$$

В конце мы еще раз воспользовались тем, что $S$ -- унитарная. Абсолютно так же доказывается, что $\hat{U}\hat{U}^{\dagger} = I.$

```{note}
Кстати, любая матрица вида $HH^{\dagger}$ является эрмитовой.
```

Давайте продемонстрируем доказанный факт на примере матрицы дискретного преобразования Фурье без нормировочного коэффициента $\frac{1}{N}$, $N=3$, преобразованной к $DD^{\dagger}$:

```{code-cell} ipython3
N = 3
w = np.sqrt(np.exp(-1j * 2 * np.pi / N))

D = np.array([
    [1, 1, 1],
    [1, w, w ** 2],
    [1, w ** 2, w ** 4]
    ])

U = D @ D.conj().T
print(f"{U = }")

print(f"{D = }")
print(f"{np.allclose(U @ U.T.conj(), np.eye(N)) = }") # no

U_hat = linalg.expm(1j * U)
print(f"\n{np.allclose(U_hat @ U_hat.conj().T, np.eye(N)) = }")
print(f"\n{np.allclose(U_hat.conj().T @ U_hat, np.eye(N)) = }")
```

### Пример: оператор-проектор

Оператором проекции является оператор $P$ со свойством $P^2=P$.

Покажем, что Ket-Bra вида $\ket{\Psi} \bra{\Psi}$ обладает этим свойством.

$$(\ket{\Psi} \bra{\Psi})^2 = \ket{\Psi} \bra{\Psi} \ket{\Psi} \bra{\Psi} = \ket{\Psi} (\bra{\Psi} \ket{\Psi}) \bra{\Psi} = \ket{\Psi} \bra{\Psi},$$

поскольку вектор состояния -- нормированный: $\bra{\Psi} \ket{\Psi} = 1$.

Оператор Ket-Bra с вектором состояния $\ket{\Psi}$, то есть $\ket{\Psi} \bra{\Psi}$рассматривается во [вводной лекции про кубиты](../../qc/ru/qubit.md), а также пригодится позже, когда речь зайдет о [смешанных состояниях](../../qc/ru/mixedstates.md).

### Пример: оператор поворота

Оператором поворота по оси вращения $v=(x,y,z)$ на угол $\theta$ является

$$
M(v,\theta) = \begin{bmatrix}
   \cos \theta + (1 - \cos \theta) x^2
 & (1 - \cos \theta) x y - (\sin \theta) z
 & (1 - \cos \theta) x z + (\sin \theta) y  
\\
   (1 - \cos \theta) y x + (\sin \theta) z
 & \cos \theta + (1 - \cos \theta) y^2
 & (1 - \cos \theta) y z - (\sin \theta) x
\\
   (1 - \cos \theta) z x - (\sin \theta) y
 & (1 - \cos \theta) z y + (\sin \theta) x
 & \cos \theta + (1 - \cos \theta) z^2
\end{bmatrix}
$$

Например, матрица поворота относительно оси $x$ на $90^\degree$: $x=1$, $y=0$, $z=0$, $\theta = \frac{\pi}{2}$, будет иметь вид:

$$
M = \begin{bmatrix}
1 & 0 & 0 \\
0 & \cos{\frac{\pi}{2}} & -\sin{\frac{\pi}{2}} \\
0 & \sin{\frac{\pi}{2}} & 1 \end{bmatrix}
$$

Если у нас больше измерений, то по тем измерениям, которые не затрагиваются этим поворотом, у нас в строке и столбце стоят нули, кроме пересечения строки и столбца, отвечающих за это измерение - там стоит единица.

Операторы поворота очень важны в квантовых вычислениях. Они рассматриваются отдельно в [лекции про квантовые гейты](../../qc/ru/gates.md) и далее используются в [вариационных квантовых схемах](../../vqc/ru/vqc.md) для кодирования классических данных в квантовые операторы.

### Пример: оператор дифференцирования

В пространстве многочленов $P$ с базисом $\{1,t,t^2,...,t^n\}$ можно задать оператор дифференцирования $\mathcal{D} \colon P_n \to P_{n-1}$ в виде матрицы:

$$
D=\begin{bmatrix}
0 & 1 & 0 & 0 & \cdots & 0 \\
0 & 0 & 2 & 0 & \cdots & 0 \\
0 & 0 & 0 & 3 &\cdots & 0 \\
\cdots & \cdots & \cdots & \cdots &\cdots & \cdots \\
0 & 0 & 0 & 0 &\cdots & n \\
\end{bmatrix}
$$

Тогда производная многочлена $p = a_0 + a_1 t  + \cdots + a_n t^{n} = \begin{bmatrix} a_0 & a_1 & \cdots & a_n \end{bmatrix} \cdot \begin{bmatrix} 1 \\ t \\ \vdots \\ t^{n} \end{bmatrix}$

$$
\mathcal{D}(p)  = \begin{bmatrix} a_0 & a_1 & \cdots & a_n \end{bmatrix} D \begin{bmatrix} 1 \\ t \\ \vdots \\ t^{n-1} \end{bmatrix} = a_1 + 2 a_2 t+\cdots+n a_n t^{n-1}.
$$

```{admonition} Про разницу между оператором и матрицей преобразования

Мы с вами рассматривали операторы через конечные матрицы, но на самом деле гильбертово пространство было придумано как раз, чтобы можно было работать с бесконечномерными векторами и применять непрерывные операторы. Можно считать, что есть некоторый дуализм между непрерывным оператором и пределом бесконечной матрицы. Иногда удобнее работать с матрицей, а иногда -- с абстрактным оператором.
```

## Произведение Кронекера

Давайте рассмотрим еще одну интересную операцию, которая называется матричным тензорным произведением (является тензорным произведением для линейных операторов) или произведением Кронекера.

Проще всего его необходимость можно продемонстрировать на примере двух игр: Орел/Решка и бросок кубика.
Мы можем записать состояния этих игр через вероятности событий и давайте возьмем монетку со смешенным центром тяжести и такой же кубик:

$\text{coin} = \begin{bmatrix} \frac{1}{3} && \frac{2}{3} \end{bmatrix}$ для нашей монетки и $\text{dice}=\begin{bmatrix} \frac{1}{4} && \frac{1}{5} && \frac{1}{7} && \frac{1}{11} && \frac{1}{13} && \frac{4791}{20020} \end{bmatrix}$ для нашей игральной кости. Тогда если мы захотим сыграть в игру, когда сначала подкидывается монетка, а потом - игральный кубик, нам будет удобно записать это в виде либо очень длинного вектора:

$$
\text{game}_{\text{vec}} = \begin{bmatrix} \frac{1}{3} \times \frac{1}{4} && \frac{1}{3} \times \frac{1}{5} && \frac{1}{3} \times \frac{1}{7} && \frac{1}{3} \times \frac{1}{11} && \frac{1}{3} \times \frac{1}{13} && \frac{1}{3} \times \frac{4791}{20020}&& \frac{2}{3} \times \frac{1}{4} && \frac{2}{3} \times \frac{1}{5} && \frac{2}{3} \times \frac{1}{7} && \frac{2}{3} \times \frac{1}{11} && \frac{2}{3} \times \frac{1}{13} && \frac{2}{3} \times \frac{4791}{20020} \end{bmatrix}
$$

Либо в виде матрицы, где по строкам будут события монетки, а по столбцам -- кубика:

$$
\text{game}_{\text{matrix}} = \begin{bmatrix} \frac{1}{3} \times \frac{1}{4} && \frac{1}{3} \times \frac{1}{5} && \frac{1}{3} \times \frac{1}{7} && \frac{1}{3} \times \frac{1}{11} && \frac{1}{3} \times \frac{1}{13} && \frac{1}{3} \times \frac{4791}{20020}\\
 \frac{2}{3} \times \frac{1}{4} && \frac{2}{3} \times \frac{1}{5} && \frac{2}{3} \times \frac{1}{7} && \frac{2}{3} \times \frac{1}{11} && \frac{2}{3} \times \frac{1}{13} && \frac{2}{3} \times \frac{4791}{20020} \end{bmatrix}
$$

С помощью произведения Кронекера (или, повторимся, -- матричного тензорного произведения) похожие огромные вектора и матрицы можно очень компактно записать:

$$
\text{game}_{\text{vec}} = \text{coin} \otimes \text{dice} \\
\text{game}_{\text{matrix}} = \text{coin}^T \otimes \text{dice}
$$

В общем случае,

$$
A \otimes B = \begin{bmatrix} a_{11} B & \cdots & a_{1n}B \\ \vdots & \ddots & \vdots \\ a_{m1} B & \cdots & a_{mn} B \end{bmatrix} =\begin{bmatrix}
   a_{11} b_{11} & a_{11} b_{12} & \cdots & a_{11} b_{1q} & \cdots & \cdots & a_{1n} b_{11} & a_{1n} b_{12} & \cdots & a_{1n} b_{1q} \\
   a_{11} b_{21} & a_{11} b_{22} & \cdots & a_{11} b_{2q} & \cdots & \cdots & a_{1n} b_{21} & a_{1n} b_{22} & \cdots & a_{1n} b_{2q} \\
   \vdots & \vdots & \ddots & \vdots & & & \vdots & \vdots & \ddots & \vdots \\
   a_{11} b_{p1} & a_{11} b_{p2} & \cdots & a_{11} b_{pq} & \cdots & \cdots & a_{1n} b_{p1} & a_{1n} b_{p2} & \cdots & a_{1n} b_{pq} \\
   \vdots & \vdots & & \vdots & \ddots & & \vdots & \vdots & & \vdots \\
   \vdots & \vdots & & \vdots & & \ddots & \vdots & \vdots & & \vdots \\
   a_{m1} b_{11} & a_{m1} b_{12} & \cdots & a_{m1} b_{1q} & \cdots & \cdots & a_{mn} b_{11} & a_{mn} b_{12} & \cdots & a_{mn} b_{1q} \\
   a_{m1} b_{21} & a_{m1} b_{22} & \cdots & a_{m1} b_{2q} & \cdots & \cdots & a_{mn} b_{21} & a_{mn} b_{22} & \cdots & a_{mn} b_{2q} \\
   \vdots & \vdots & \ddots & \vdots & & & \vdots & \vdots & \ddots & \vdots \\
   a_{m1} b_{p1} & a_{m1} b_{p2} & \cdots & a_{m1} b_{pq} & \cdots & \cdots & a_{mn} b_{p1} & a_{mn} b_{p2} & \cdots & a_{mn} b_{pq}
\end{bmatrix}

$$

Основные его свойства вы можете прочитать в статье: [_Произведение Кронекера_](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D0%9A%D1%80%D0%BE%D0%BD%D0%B5%D0%BA%D0%B5%D1%80%D0%B0)

Есть и другие нужные тензорные операции, например, чуть больший список вы можете найти в [этой статье](https://habr.com/ru/post/369925/) или в рекомендованной литературе по квантовой механике.

## Рекомендованная литература

- Quantum Mechanics: The Theoretical Minimum Illustrated Edition by Leonard Susskind, Art Friedman {cite}`susskind2014quantum` или его русский перевод {cite}`susskind2014quantum-ru`. Книга сочетает в себе довольно строгий формализм вместе с интуицией квантовой механики. Главы построены в виде конкретных примеров или задач, которые понимают, зачем та или иная теория необходима.
- Mathematics for machine learning by Marc Peter Deisenroth, A. Aldo Faisal, and Cheng Soon Ong {cite}`deisenroth2020mathematics` - отличная книжка чтобы освежить воспоминания о базовых алгоритмах в машинном обучении и о математике, которая применяется в них. [_Доступна бесплатная электронная версия_](https://mml-book.github.io/book/mml-book.pdf).
- Deep Learning by Ian Goodfellow, Yoshua Bengio, Aaron Courville {cite}`Goodfellow-et-al-2016` - отличная книжка, чтобы разобраться в основах глубокого обучения, чем-то может заменить предыдущую книгу, отличный старт, если вы хотите разобраться в автоэнкодерах или в других нейросетевых моделях.
[_Доступна бесплатная электронная версия_](https://www.deeplearningbook.org/).

## Что мы узнали

- произвол со скобками
- Гильбертовы пространства
- Эрмитовый оператор
- Унитарный оператор
- Примеры различных операторов
